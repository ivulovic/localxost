<div class="content-title">NodeJS</div>

<ClipboardLink id="set-up-nodejs-server"></ClipboardLink>

<p>
  When you're connecting NodeJS server with some other framework, React or Angular, file where
  you will set up server should be in the same folder as <b>package.json</b>of client. That's because in the
  <b>package.json</b> you will have scripts which run the file. To make it more simple here's the structure how it should look.
</p>

<Code title="Set up NodeJS Server | Folder Structure ">
<pre>
<Icon icon="folder-open-o"></Icon> server
<Icon icon="folder-open-o"></Icon> src
<Icon icon="file-o"></Icon> server.js
<Icon icon="file-o"></Icon> package.json
</pre>
</Code>

<p>To set up NodeJS server we will use express. Just run the following command.</p>

<Code title="cmd">
<pre>
npm install --save express body-parser  
</pre>
</Code>

<p>Setting NodeJS server is easy.</p>

<Code title="server.js">
<pre>
const express = require("express");
const bodyParser = require("body-parser");
const app = express();
const path = require("path");

app.use(express.static(__dirname+'/dist'))
app.use(bodyParser.json(&#123;limit: '1mb'&#125;)); // limit is useful when you have file upload, so you want that you only upload files up to 1 MB

app.use((err, req, res, next) =&gt; &#123;
  const error = app.get("env") === "development" ? err : &#123;&#125;;                  // if the error occurs in the server side
  const status = err.status || 500;                                           // this will output error in the console
  res.status(status).json(&#123;error: &#123; message: error.message &#125; &#125;);
  console.log(error.message);
  next();
&#125;);

app.get('*', function(req, res)&#123;
  res.sendFile(path.join(__dirname+'/dist/index.html')); // be sure that you always send this file that gets created in dist folder after build
&#125;);

app.listen(process.env.PORT || 3000, ()=&gt; console.log("App is up and running!"));
</pre>
</Code>

<ClipboardLink id="proxy-requests-from-client-to-server"></ClipboardLink>

<p>Why do you need this? Because when you have two servers each server has own SessionID and in that way
is impossible to do authentication or some more other security related stuff.</p>

<p><b><button type="button" class="button-icon button-error"><Icon icon="exclamation-circle"></Icon> NOTE: YOU DO THIS ONLY ON CLIENT SIDE</button></b></p>
<p>You might think: So what, i'm on port 8080 and i just have to call api with port 3000, and i will get all data.</p>

<p>And you will, but in that case when you have to deploy app then you have always change that 3000 port to the some other port you don't know or gets generated by hosting provider.
In this way we proxy requests from the port 8080 to the 3000. In that way we will have same SessionID or anything else we need.
</p>

<p>On server side you don't use this proxy requests because your app gets bundled into <b>dist</b> folder and <b>server.js</b>
file directly refers to the <b>index.html</b> file.</p>

<p>So we will have to change <b>package.json</b> file, and to add <b>proxy.conf.json</b> file.</p>

<p>Your folder structure now should look like something like this.</p>


<Code title="Proxy Requests From Client to Server | Folder Structure ">
<pre>
<Icon icon="folder-open-o"></Icon> server
<Icon icon="folder-open-o"></Icon> src
<Icon icon="file-o"></Icon> server.js
<Icon icon="file-o"></Icon> package.json
<Icon icon="file-o"></Icon> proxy.conf.json
</pre>
</Code>

<p>Here's proxy configuration.</p>

<Code title="proxy.conf.json">
<pre>
&#123;
  "/api": &#123;
    "target": "http://localhost:3000",
    "secure": false,
    "logLevel": "debug",
    "changeOrigin": true
  &#125;
&#125;  
</pre>  
</Code>

<p>In <b>package.json</b> file under <b>scripts</b> add this: </p>

<Code title="package.json">
<pre>
"proxy": "ng serve -o --port 8080 --proxy-config proxy.conf.json",
</pre>
</Code>

<p>Now any endpoint that starts with <b>/api</b> will be replaced with <b>http://localhost:3000</b>.</p>

<ClipboardLink id="working-on-server-side"></ClipboardLink>

<p>Let's see how to work on server side. We will set up routes, controllers and mongoose models.</p>

<p>You will need following dependencies.</p>

<Code title="cmd">
<pre>
npm install --save joi express express-promise-router mongoose mongoose-auto-increment
</pre>
</Code>

<p>Let's see folder structure.</p>

<Code title="Working on server side | Folder Structure ">
<pre>
<Icon icon="folder-open-o"></Icon> server
  <Icon icon="folder-open-o"></Icon> helpers
    <Icon icon="file-o"></Icon> route.helper.js
  <Icon icon="folder-open-o"></Icon> controllers
    <Icon icon="file-o"></Icon> article.controller.js
  <Icon icon="folder-open-o"></Icon> routes
    <Icon icon="file-o"></Icon> article.routes.js
  <Icon icon="folder-open-o"></Icon> models
    <Icon icon="file-o"></Icon> article.model.js
  <Icon icon="file-o"></Icon> constants.js
<Icon icon="file-o"></Icon> server.js
</pre>
</Code>

<p>Let's see what's inside <b>constants.js</b> file.</p>

<Code title="/server/constants.js">
<pre>
module.exports = &#123;
  dbProd: "mongodb://yourUserUsername:yourUserPassword@MLAB_ADDRESS_THEY_GAVE_YOU/yourDB",
  dbDev: "mongodb://localhost/yourDB",
  distributionRoot: "dist",
  routes:"./server/routes/"
&#125;
</pre>
</Code>

<p>In <b>helpers</b> we will provide helpers for route validation when sending request from the client. We will have
validator for params and for body, depending from the defined schema.</p>

<Code title="/server/helpers/route.helper.js">
<pre>
const Joi = require("joi");
module.exports =  &#123;
  validateParams: (schema, name) =&gt; &#123;
    return (req, res, next) =&gt; &#123;
      const result = Joi.validate(&#123; param: req["params"][name] &#125;, schema);
      if(result.error)&#123;
        return res.status(400).json(result.error);
      &#125; else &#123;
        if(!req.value)
          req.value = &#123;&#125;;
        if(!req.value["params"])
          req.value["params"] = &#123;&#125;;
        req.value["params"][name] = result.value.param;
        next();
      &#125;
    &#125;
  &#125;,
  validateBody: (schema) =&gt; &#123;
    return (req, res, next) =&gt; &#123;
      const result = Joi.validate(req.body, schema);
      if(result.error)&#123;
        return res.status(400).json(result.error);
      &#125; else &#123;
        if(!req.value)
          req.value = &#123;&#125;;
        if(!req.value["body"])
          req.value["body"] = &#123;&#125;
        req.value["body"] = result.value;
        next();
      &#125;
    &#125;
  &#125;,
  schemas: &#123;
    objectId: Joi.object().keys(&#123;
      param: Joi.string().regex(/^[0-9a-fA-F]&#123;24&#125;$/).required()
    &#125;),
    id:Joi.object().keys(&#123;
      param: Joi.number().min(0).required()
    &#125;),
    article: &#123;
      required: Joi.object().keys(&#123;
        title: Joi.string().required(),
        description: Joi.string().required(),
        category: Joi.string().regex(/^[0-9a-fA-F]&#123;24&#125;$/).required(),
        author: Joi.string().regex(/^[0-9a-fA-F]&#123;24&#125;$/).required(),
        created: Joi.date().timestamp().required()
      &#125;)
    &#125;
  &#125;
&#125;;
</pre>
</Code>

<p>Here we defined two schemas. These schemas will be used when sending request to the server. All field that are under <b>required</b> object will be
required to be sent.</p>

<p>Let's define Article model.</p>

<Code title="/server/models/article.model.js">
<pre>
const express = require("express");
const mongoose = require("mongoose");
const Schema = mongoose.Schema;
const autoIncrement = require("mongoose-auto-increment");
const &#123;dbDev, dbProd&#125; = require("../constants");
const app = express();
const connection = mongoose.createConnection(app.get("env") === "development" ? dbDev : dbProd);
autoIncrement.initialize(connection);

const ArticleSchema = new Schema(&#123;
  title: String,
  description: String,
  category: &#123;                    //just a example how to ref category
    type: Schema.Types.ObjectId,
    ref: "category"
  &#125;, 
  author: &#123;
    type: Schema.Types.ObjectId,
    ref: "user"
  &#125;,
  created: Number
&#125;);

ArticleSchema.plugin(autoIncrement.plugin, &#123;model: "article", field:"articleId"&#125;);
const ArticleModel = mongoose.model("article", ArticleSchema);
module.exports = ArticleModel;
</pre>  
</Code>

<p>MongooseAutoIncrement plugin automaticly creates an integet ID, because MongoDB has only ObjectID created.</p>

<p>Let's create controller now.</p>

<Code title="/server/controllers/article.controller.js">
<pre>
const ArticleModel = require("../models/article.model");

module.exports = &#123;
  getArticles: async(req, res) =&gt; &#123;
    const result = await ArticleModel.find().populate("category").populate("author", &#123;password: 0&#125;).populate(&#123;
      path: 'comments',                                           // just a example how to populate
      populate: &#123;path: 'author', select:'-password'&#125;,             // deep object into comments array
    &#125;);
    res.status(200).json(result);
  &#125;,
&#125;  
</pre>  
</Code>

<p>And finally we create our route.</p>

<Code title="/server/routes/article.routes.js">
<pre>
const router = require("express-promise-router")();
const ArticleController = require("../controllers/article.controller");
const &#123;validateParams, validateBody, schemas&#125; = require("../helpers/route.helper");
const config = require("../config/database");

router.route("/")
  .get(ArticleController.getArticles)

// example how we use validators
// router.route("/:articleId")
//  .get(validateParams(schemas.id, "articleId"), ArticleController.getArticle)
//  .put([validateParams(schemas.id, "articleId"), validateBody(schemas.article.required)], ArticleController.updateArticle)
//  .delete(validateParams(schemas.objectId,"articleId"),ArticleController.removeArticle);

module.exports = router;
</pre>
</Code>

<p>Okay, now as last thing we need to add this to our <b>server.js</b> file.</p>

<Code title="server.js">
<pre>
const express = require("express");
const mongoose = require("mongoose");
const bodyParser = require("body-parser");
const &#123;dbProd, dbDev, distributionRoot, routes&#125; = require("./server/constants");
const app = express();
const path = require("path");
mongoose.connect(app.get("env") === "development" ? dbDev : dbProd);

// our article route
const articles = require(routes+"article.routes");

app.use(express.static(__dirname+'/'+distributionRoot))
app.use(bodyParser.json(&#123;limit: '1mb'&#125;));

app.use((req, res, next) =&gt; &#123;
  res.header('Access-Control-Allow-Origin', req.headers.origin);
  res.header("Access-Control-Allow-Headers", "Content-Type");
  next();
&#125;);

// tell app to use these routes we created
app.use("/api/articles", articles);

app.use((err, req, res, next) =&gt; &#123;
  const error = app.get("env") === "development" ? err : &#123;&#125;;
  const status = err.status || 500;
  res.status(status).json(&#123;error: &#123; message: error.message &#125; &#125;);
  console.log(error.message);
  next();
&#125;);

app.get('*', function(req, res)&#123;
  res.sendFile(path.join(__dirname+'/'+distributionRoot+'/index.html'))
&#125;);

app.listen(process.env.PORT || 3000, ()=&gt; console.log("App is up and running!"));
</pre>
</Code>

<p>That's how we set up our server. Now it just have to be invoked. Note that we used MongoDB here, so if you don't have it
got to <button type="button" (click)="goToExternalLink('https://www.mongodb.com/download-center/v2/community')" class="button-icon button-link-outline"><Icon icon="paper-plane"></Icon> MongoDB website</button> and download it.
  Don't forget to invoke route with <b>/api/articles</b>, then your request will be proxied to the other port.
</p>